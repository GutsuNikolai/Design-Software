# Кратко о реализованном решении и покрытии пунктов задания

**Цель:**  
Нужно было обеспечить гибкую передачу свойств объекта между слоями/модулями без жёсткой структуры классов.  
Для этого реализован **контекст с динамическими свойствами** и **типизированные ключи** (паттерн *Typed Key*).

Контекст - класс, представляющий собой "контейнер" для данных используемых в разных частях проекта. Он позволяет им использовать и обмениваться данными не вникая в детали реализации друг-друга, просто передавая их по определенным правилам.
Это позволяет сделать гибкую структуру проекта, с множеством модулей без жесткой зависимости между ними.

## Что сделано в коде

### TypedKey + KeyRegistry

Создан объект-ключ `TypedKey(name, value_type)` и **глобальный реестр ключей** `KeyRegistry`.

- Реестр гарантирует **уникальность имён** ключей (если имя уже занято — выбрасывается ошибка).
- У каждого ключа хранится ожидаемый **тип значения** (например, `"user.id": int`).
- При работе с данными выполняется **проверка типа во время выполнения (рантайм-проверка)**.

### **Context (динамическое хранение свойств)**

Класс `Context` хранит данные в словаре (ассоциативный массив), но доступ к ним возможен **только через TypedKey**.

Для добавления/извлечения данных используются геттеры и сеттеры, с проверкой типа данных (проверка типо по isinstance)

### "Библиотека", не зависящая от конкретных сущностей

Модуль `library_api` **сам регистрирует** свои ключи (`USER_ID`, `USER_NAME`, `REQUEST_ID`)  
и реализует операции (`GreetUser`, `TraceRequest`), которые **читают данные из Context** по этим ключам.

Библиотека полностью **изолирована от пользовательских моделей** и работает только через ключи,  
что обеспечивает универсальность и повторное использование.

### Демонстрация использования (проект-потребитель)

В файле `main.py` создаётся экземпляр `Context`, заполняется значениями под ключами библиотеки  
и выполняются операции библиотеки (`GreetUser`, `TraceRequest`).

Это демонстрирует взаимодействие между разными проектами (библиотека ↔ потребитель) через единый интерфейс — `Context` и зарегистрированные ключи.

## Теоретическая часть

1. Примеры из фреймворков  

    - ASP.NET `HttpContext.Items`
    - FastAPI `request.state`
    - Python `contextvars`
2. Почему не подходит `FatStruct`?
    - `FatStruct` не подходит, так как он заранее определяет набор всех возможнных полей, пытаясь предосмотреть все возможные сценарии использования. Но по итогу получается очень большая, "громоздкая"  структура, большая часть полей которой просто не используются.
    - Второй минус - если пользователь захочет ввести свой ключ - он не сможет, так как эта структура константна.
    - Жесткая связанность кода - изменение в одном месте может потянуть за собой череду ошибок.
    - Плохая гибкость - трудно передавать данные между разными частями проекта, если в структуре нет нужных полей (предусмотренные не покрыли все случаи)
3. Краткое сравнение подходов
    - FatStruct уже рассмотрен выше
    - Ассоциативный массив реализован в коде
    - Массив свойств Object[]: несмотря на простоту реализации и быстроту работы этого метода, у него есть и минусы:
        1. Связь по порядку - перепутать объекты = получить ошибку
        2. Достает и кладем просто по индексу = не особо понятно что именно
        3. Нельзя вставить данные в середину = сломаем остальные части проекта, которые используют текующие индексы
        4. Типы данных не контролируются, нужно делать проверки отдельно
    - ECS - современный способ строить гибкие структуры данных пришедший из гейм-дева. Он разделяет объект на 3 части: сущность(просто идентификатор указывающий на объект), компоненты - логически-объединенный набор данных объекта конкретной сущности, и система - логика, которая управляет всеми сущностями обладающими определенным компонентом. Это делает систему гибкой, легко добавлять новые сущности и типы компонентов, не переписывая старые + работает быстро, так как данные обрабатываются индивидуально (отельная сисмтема отдельно). Однако гораздо труднее в реализации.
